#########
# perl header & footer module designed for mod_perl use
# Author: rmp
# Maintainer: rmp
# Date: 2002-02-26
#

package SiteDecor::meropstest;
use strict;
use warnings;
use base qw(SiteDecor);

sub init_defaults {
  my $self = shift;
  my $def  = {
	      "author"      => 'webmaster',
	      "decor"       => 'full',
	      'bannercase'  => 'ucfirst',
        'title'       => 'MEROPS - the Peptidase Database',
	      'stylesheet'  => ['/css/main.css'],
        'body_class'  => '',
	     };
  $self->merge($def);
}

sub fields {
  my $self = shift;
  my @fields = $self->SUPER::fields;
  push @fields, qw( body_class );
  return @fields;
}

sub html_headers {
  my $self   = shift;
  my $html_headers = $self->SUPER::html_headers();

#############################################
# Determine $config_file

  my $inifile = $self->{'inifile'};
  my $req_uri = $ENV{'REQUEST_URI'} || q();

  if($self->ini_loaded()) {
    return;
  }

  if(!$inifile && $req_uri =~ /^\/(perl|cgi\-bin)/mx) {
    return;
  }

  my ($header,$header_global);

  if($inifile) {
    #########
    # determine full path to configured header files
    #

    my $req = $ENV{'REQUEST_URI'};     # path to script

    my $tld;
    # Strip cgi-bin or perl:
    if($req =~ m!/(cgi-bin|perl)/([^/]+)/!mx) {
      $tld = $2;
    } elsif($req !~ /(cgi-bin|perl)/mx) {
      ($tld) = $req =~ m|/([^/]+)/$|mx;                      # last part of path (?)
    }
    $tld           = $tld?"$tld/":q();                       # add a backslash

    ($header)      = $inifile =~ /([a-zA-Z0-9\/\_\-\.]+)/mx; # anything from inifile
    my $dr          = $ENV{'DOCUMENT_ROOT'} ||q();
    $header         = qq($dr/$tld$header);
    $header_global  = qq($dr/default_sidebar.yml);           # just look at root for default sidebar      
  }
  else {
    #########
    # try to automatically determine header files
    #
    my ($directory) = $req_uri =~ /^(.+)\//mx;
    my ($tld)       = $req_uri =~ /^(.+?)\//mx;
    $directory    ||= q();
    $tld          ||= q();
    my $dr          = $ENV{'DOCUMENT_ROOT'} ||q();
    $header         = qq($dr$directory/sidebar.yml);
    $header_global  = qq($dr/default_sidebar.yml);
  }

  $header        =~ s|//|/|mxg;

  my $sidebar = q();
  my $sidebar_id = q();
  my $header_file = q();
  if(-f $header) {
    $header_file = $header;
  }
  elsif (-f $header_global) {
    $header_file = $header_global;
  }

  if ($header_file) {
    eval {
      my $config = YAML::LoadFile($header_file);
      $sidebar = q();
      for my $entry (@$config) {
        if ($entry->{'html_sidebar_id'}) {
          $sidebar_id = q( id=').$entry->{'html_sidebar_id'}.q(');
        }
        else {
          $sidebar .= $self->create_menu($entry);
        } 
      }
    };
    if ($@) {
      warn "Problems : $@";
    }
    $self->ini_loaded(1);
  } 
  else  {
    $sidebar = q(You need a default_sidebar.yml);
    warn ("Not found: $header_file");
  }

  $html_headers .= qq(  <div class="sidebar"$sidebar_id>
      $sidebar
  </div><!-- end sidebar -->
  <div class="content">\n);

  return $html_headers;
}

sub site_body_tag {
  my $self   = shift;
  my $onload = $self->onload() || q();
  my $class  = $self->body_class() || q{};
  $class     = $class?qq( class="$class"):q{};

  if(grep { m|/js/sidebar.js|mx } @{$self->jsfile()}) {
    $onload = "sidebar_default(); $onload;";
  }
	$onload  = $onload?qq( onload="$onload"):q();
  return sprintf qq(  <body%s%s>), $class, $onload;
}

sub site_headers {
  my $self = shift;
  my $site_headers = q{};

  if(defined $self->{'banner'}) {
    my $banner = "";
    if($self->{'bannercase'} eq "uc") {
      $banner = uc($self->{'banner'});
    } elsif($self->{'bannercase'} eq "ucfirst") {
      $banner = ucfirst($self->{'banner'});
    } else {
      $banner = lc($self->{'banner'});
    }
    $site_headers .= $self->site_banner($banner);
  }

  return $site_headers;
}

sub site_banner {
  my ($self, $heading) = @_;

  return qq(<h1>$heading</h1>);
}

sub get_time {
  my ( $time ) = @_;
  my ( $sec, $min, $hour, $mday, $mon, $year, $wday, $yday) = gmtime $time; #gmtime($time);
  my $month = qw (January February March April May June July August September October November December)[$mon];
     $year = $year + 1900;
  return sprintf '%2d-%s-%4d',$mday,$month,$year;
}

sub site_footers {
  my $self = shift;

  my $lastmod = q();
  my $req_uri = $ENV{'REQUEST_URI'} || q();

  if($ENV{'LAST_MODIFIED'}) {
    $lastmod = qq(Last Modified $ENV{'LAST_MODIFIED'});

  } 
  else {
    #########
    # Look for the request_uri document
    #
    my ($fn) = "$ENV{'DOCUMENT_ROOT'}/$req_uri" =~ m|([a-z\d\./_]+)|mix;

    #########
    # If that doesn't exist try the script_filename
    #
    if($fn && !-e $fn) {
      ($fn) = $ENV{'SCRIPT_FILENAME'}||q() =~ m|([a-z\d\./_]+)|mix;
    }

    if($fn && -e $fn) {
      my ($mtime)     = (stat $fn)[9];
      if ($mtime) {
        $lastmod = 'Page created '. get_time($mtime);
      }
    }
  }

  
  return qq(
      <div class="footer">
        <p class="right">$lastmod</p>
        <p class="left">Funding from the <a href="http://www.wellcome.ac.uk">Wellcome Trust</a></p>
        <p class="middle">&copy; 2008 WTSI<br><a href="/about/about_10.htm">Terms of use</a></p>
      </div>
    </div><!-- end class content -->
  </body>
</html>\n);
}

sub create_menu {
  my ($self,$entry) = @_;
  my $output = q{};
  while ((my $key, my $value) = each %$entry) {
    if (ref $value eq 'HASH') {

      my $is_li = 0;
      my ($has_children_s,$has_children_e) = ('','');
      if ($value->{'class'} && $value->{'class'} ne 'title' && $value->{'class'} ne 'switch' && $value->{'class'} !~ /^bigtext/ )
        {
        if ($is_li && $value->{'sub'} && @{$value->{'sub'}})
          {
          $has_children_s = "<ul>";
          $has_children_e = "</ul>";
          $is_li = 1;
          }
        }
 
      my $class = ($value->{'class'}) ? qq( class="$value->{'class'}"): q();
      my $title = ($value->{'title'}) ? qq( title="$value->{'title'}"): q();

      $output .= $is_li ? qq($has_children_s<li>):q();
      my $close = q();

      if ($value->{'link'})
        {
        $output .= qq(<a href="$value->{'link'}"$class$title>$key</a>);
        $close = qq(\n);
        }
      else
        {
        $output .= qq(<p$class>$key</p>);
        $close = qq(\n);
        }
      $close .= $is_li ? qq(</li>$has_children_e):q();
      if ($value->{'sub'} && @{$value->{'sub'}})
        {
        $output .= "\n<ul>\n";
        for my $sub (@{$value->{'sub'}}) {
          $output .= '  '.list_items($self,$sub);
          }
        $output .= '</ul>';
        }
      $output .= $close."\n";
    }
    else {
      if ($value)
        {
        $output.= qq(<a href="$value">$key</a>\n);
        }
      else
        {
        $output.= $key."\n";
        }
    }
  }
  return $output;
}

sub list_items
{
  my ($self,$entry) = @_;
  my $output = q{};
  while ((my $key, my $value) = each %$entry) {
    if (ref $value eq 'HASH') {

      my $class = ($value->{'class'}) ? qq( class="$value->{'class'}"): q();
      my $title = ($value->{'title'}) ? qq( title="$value->{'title'}"): q();

      my $close = '';
      if ($value->{'link'})
        {
        $output .= qq(<li><a href="$value->{'link'}"$class$title>$key);
        $close = qq(</a></li>);
        }
      else
        {
        $output .= '<li$class>'.$key;
        $close = qq(</li>\n);
        }
      if ($value->{'sub'} && @{$value->{'sub'}})
        {
        $output .= "<ul>\n";
        for my $sub (@{$value->{'sub'}}) {
          $output .= '  '.list_items($self,$sub);
          }
        $output .= '</ul>';
        }
      $output .= $close."\n";
    }
  }
  return $output;
}


sub doc_type {
  return qq(<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">\n);
}

1;
